import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
import xgboost as xgb
from sklearn.metrics import mean_absolute_error, r2_score
from sklearn.model_selection import RandomizedSearchCV
from sklearn.inspection import PartialDependenceDisplay
import shap

# Load the data
commodities_df = pd.read_csv('Data/gbr_commodities_1d.csv')
system_2018_df = pd.read_csv('Data/gbr_system_30M_2018.csv')
system_2019_df = pd.read_csv('Data/gbr_system_30M_2019.csv')
technology_2018_df = pd.read_csv('Data/gbr_technology_30M_2018.csv')
technology_2019_df = pd.read_csv('Data/gbr_technology_30M_2019.csv')

# Convert datetime columns to datetime type
commodities_df['local_date'] = pd.to_datetime(commodities_df['local_date'])
system_2018_df['date_time_utc'] = pd.to_datetime(system_2018_df['date_time_utc'])
system_2019_df['date_time_utc'] = pd.to_datetime(system_2019_df['date_time_utc'])
technology_2018_df['date_time_utc'] = pd.to_datetime(technology_2018_df['date_time_utc'])
technology_2019_df['date_time_utc'] = pd.to_datetime(technology_2019_df['date_time_utc'])

# data cleaning
technology_2018_df = technology_2018_df.iloc[:, :4]
technology_2019_df = technology_2019_df.iloc[:, :4]

# Concatenate system and technology data for both years
system_df = pd.concat([system_2018_df, system_2019_df])
technology_df = pd.concat([technology_2018_df, technology_2019_df])
# Calculate the daily average of the wholesale prices
system_df['date'] = system_df['date_time_utc'].dt.date
daily_system_df = system_df.groupby('date')['wholesale market price, gbp/mwh'].mean().reset_index()
daily_system_df['date'] = pd.to_datetime(daily_system_df['date'])

# Merge the daily average wholesale prices with the commodity prices
commodities_df = commodities_df.rename(columns={'local_date': 'date'})
merged_df = pd.merge(daily_system_df, commodities_df, on='date', how='left')

# Drop rows with missing values in the target variable or any features
merged_df.dropna(subset=['wholesale market price, gbp/mwh', 'gas price, gbp/mmbtu', 'coal price, gbp/tonne',
                         'carbon price, gbp/tonne'], inplace=True)

# Create datetime features
merged_df['dayofweek'] = merged_df['date'].dt.dayofweek
merged_df['month'] = merged_df['date'].dt.month

# Add lagged features
merged_df['lag_1'] = merged_df['wholesale market price, gbp/mwh'].shift(1)
merged_df['lag_7'] = merged_df['wholesale market price, gbp/mwh'].shift(7)
merged_df['lag_30'] = merged_df['wholesale market price, gbp/mwh'].shift(30)

# Add rolling statistics
merged_df['rolling_mean_7'] = merged_df['wholesale market price, gbp/mwh'].rolling(window=7).mean()
merged_df['rolling_std_7'] = merged_df['wholesale market price, gbp/mwh'].rolling(window=7).std()
merged_df['rolling_mean_30'] = merged_df['wholesale market price, gbp/mwh'].rolling(window=30).mean()
merged_df['rolling_std_30'] = merged_df['wholesale market price, gbp/mwh'].rolling(window=30).std()

# Drop rows with NaN values generated by shift and rolling operations
merged_df.dropna(inplace=True)

# Filter only necessary columns for modeling
model_df = merged_df[['date', 'wholesale market price, gbp/mwh', 'gas price, gbp/mmbtu', 'coal price, gbp/tonne',
                      'carbon price, gbp/tonne', 'dayofweek', 'month', 'lag_1', 'lag_7', 'lag_30',
                      'rolling_mean_7', 'rolling_std_7', 'rolling_mean_30', 'rolling_std_30']]


# Fit a line for Gas Price
X_gas = merged_df['gas price, gbp/mmbtu'].values.reshape(-1, 1)
y = merged_df['wholesale market price, gbp/mwh'].values
model_gas = LinearRegression().fit(X_gas, y)
y_gas_pred = model_gas.predict(X_gas)
r2_gas = r2_score(y, y_gas_pred)

# Fit a line for Coal Price
X_coal = merged_df['coal price, gbp/tonne'].values.reshape(-1, 1)
model_coal = LinearRegression().fit(X_coal, y)
y_coal_pred = model_coal.predict(X_coal)
r2_coal = r2_score(y, y_coal_pred)

# Print coefficients and R2 scores
print(f"Gas Price Model: Coefficient = {model_gas.coef_[0]}, Intercept = {model_gas.intercept_}, R2 = {r2_gas}")
print(f"Coal Price Model: Coefficient = {model_coal.coef_[0]}, Intercept = {model_coal.intercept_}, R2 = {r2_coal}")

# Plotting the relationships with fitted lines
plt.figure(figsize=(8, 8))

plt.subplot(2, 1, 1)
plt.scatter(merged_df['gas price, gbp/mmbtu'], merged_df['wholesale market price, gbp/mwh'], color='blue')
plt.plot(merged_df['gas price, gbp/mmbtu'], y_gas_pred, color='red', label='Fitted Line')
plt.xlabel('Gas Price (GBP/MMBtu)')
plt.ylabel('Wholesale Market Price (GBP/MWh)')
plt.title('Gas Price vs Wholesale Market Price')
plt.legend()

plt.subplot(2, 1, 2)
plt.scatter(merged_df['coal price, gbp/tonne'], merged_df['wholesale market price, gbp/mwh'], color='orange', label='Coal Price')
plt.plot(merged_df['coal price, gbp/tonne'], y_coal_pred, color='red', label='Fitted Line For Coal/Power Price')
plt.scatter(merged_df['carbon price, gbp/tonne'], merged_df['wholesale market price, gbp/mwh'], color='green', label='Carbon Price')
plt.xlabel('Commodity Prices (GBP/tonne)')
plt.ylabel('Wholesale Market Price (GBP/MWh)')
plt.title('Coal and Carbon Prices vs Wholesale Market Price')
plt.legend()

plt.tight_layout()
plt.show()


# Plotting the relationships
plt.figure(figsize=(12, 8))

plt.subplot(3, 1, 1)
plt.plot(model_df['date'], model_df['wholesale market price, gbp/mwh'], label='Wholesale Market Price (GBP/MWh)', color='blue')
plt.ylabel('Price (GBP/MWh)')
plt.title('Wholesale Market Price')
plt.legend()

plt.subplot(3, 1, 2)
plt.plot(model_df['date'], model_df['gas price, gbp/mmbtu'], label='Gas Price (GBP/MMBtu)', color='orange')
plt.ylabel('Price (GBP/MMBtu)')
plt.title('Gas Price')
plt.legend()

plt.subplot(3, 1, 3)
plt.plot(model_df['date'], model_df['coal price, gbp/tonne'], label='Coal Price (GBP/tonne)', color='green')
plt.plot(model_df['date'], model_df['carbon price, gbp/tonne'], label='Carbon Price (GBP/tonne)', color='red')
plt.xlabel('Date')
plt.ylabel('Price (GBP/tonne)')
plt.title('Coal and Carbon Prices')
plt.legend()

plt.tight_layout()
plt.show()


# Merge system and technology data on the date_time_utc column
merged_df2 = pd.merge(system_df, technology_df, on='date_time_utc', how='left')

# Resample commodities data to match the frequency of the merged data
commodities_df = pd.read_csv('Data/gbr_commodities_1d.csv')
commodities_df['local_date'] = pd.to_datetime(commodities_df['local_date'])
commodities_df.set_index('local_date', inplace=True)
commodities_resampled_df = commodities_df.resample('30min').ffill().reset_index()

# Merge the commodities data with the merged system and technology data
final_df = pd.merge(merged_df2, commodities_resampled_df, left_on='date_time_utc', right_on='local_date', how='left')


# renewable vs non renewable
renewable_methods = ['Offshore Wind', 'Onshore Wind', 'Solar', 'Hydro', 'Biomass']
non_renewable_methods = ['CCGT', 'Coal', 'Gas CHP-CCGT', 'Nuclear', 'OCGT', 'Oil']

# Filter the data
renewable_df = final_df[final_df['name'].isin(renewable_methods)]
non_renewable_df = final_df[final_df['name'].isin(non_renewable_methods)]

# Aggregate total generation for each renewable method
total_generation = renewable_df.groupby('name')['total generation, mwh'].sum().reset_index()

# Calculate average load factor for each renewable method
average_load_factor = renewable_df.groupby('name')['load factor, %'].mean().reset_index()

# Create subplots
fig, ax1 = plt.subplots(2, 1, figsize=(7, 9))

# Plot total generation
ax1[0].bar(total_generation['name'], total_generation['total generation, mwh'], color='green')
ax1[0].set_title('Total Generation by Renewable Method')
ax1[0].set_xlabel('Renewable Method')
ax1[0].set_ylabel('Total Generation (MWh)')
ax1[0].grid(True)

# Plot average load factor
ax1[1].bar(average_load_factor['name'], average_load_factor['load factor, %'], color='blue')
ax1[1].set_title('Average Load Factor by Renewable Method')
ax1[1].set_xlabel('Renewable Method')
ax1[1].set_ylabel('Average Load Factor (%)')
ax1[1].grid(True)

# Adjust layout and show plot
plt.tight_layout()
plt.show()


# Group by week and sum the total generation for better visibility
renewable_df['week'] = renewable_df['date_time_utc'].dt.to_period('W')
non_renewable_df['week'] = non_renewable_df['date_time_utc'].dt.to_period('W')

renewable_grouped_weekly = renewable_df.groupby('week')['total generation, mwh'].sum().reset_index()
non_renewable_grouped_weekly = non_renewable_df.groupby('week')['total generation, mwh'].sum().reset_index()

# Drop the last week if you don't want it
renewable_grouped_weekly = renewable_grouped_weekly.iloc[:-1]
non_renewable_grouped_weekly = non_renewable_grouped_weekly.iloc[:-1]

# Convert the week period to datetime for plotting
renewable_grouped_weekly['week'] = renewable_grouped_weekly['week'].dt.to_timestamp()
non_renewable_grouped_weekly['week'] = non_renewable_grouped_weekly['week'].dt.to_timestamp()

# Plotting renewable and non-renewable generation by week
plt.figure(figsize=(8, 6))
plt.plot(renewable_grouped_weekly['week'], renewable_grouped_weekly['total generation, mwh'], label='Renewable Generation', color='green', alpha=0.7)
plt.plot(non_renewable_grouped_weekly['week'], non_renewable_grouped_weekly['total generation, mwh'], label='Non-Renewable Generation', color='orange', alpha=0.7)
plt.legend()
plt.title('Comparison of Renewable and Non-Renewable Generation (Weekly)')
plt.xlabel('Month')
plt.ylabel('Total Generation (MWh)')
plt.grid(True)
plt.gca().xaxis.set_major_locator(mdates.MonthLocator())
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%b %Y'))
plt.xticks(rotation=45)
plt.show()

# Group by week and calculate the mean load factor for renewable and non-renewable methods
renewable_load_factor_weekly = renewable_df.groupby('week')['load factor, %'].mean().reset_index()
non_renewable_load_factor_weekly = non_renewable_df.groupby('week')['load factor, %'].mean().reset_index()

# Drop the last week if you don't want it
renewable_load_factor_weekly = renewable_load_factor_weekly.iloc[:-1]
non_renewable_load_factor_weekly = non_renewable_load_factor_weekly.iloc[:-1]

# Convert the week period to datetime for plotting
renewable_load_factor_weekly['week'] = renewable_load_factor_weekly['week'].dt.to_timestamp()
non_renewable_load_factor_weekly['week'] = non_renewable_load_factor_weekly['week'].dt.to_timestamp()

# Plotting load factor for renewable and non-renewable generation by week
plt.figure(figsize=(8, 6))
plt.plot(renewable_load_factor_weekly['week'], renewable_load_factor_weekly['load factor, %'], label='Renewable Load Factor', color='blue', alpha=0.7, linewidth=1)
plt.plot(non_renewable_load_factor_weekly['week'], non_renewable_load_factor_weekly['load factor, %'], label='Non-Renewable Load Factor', color='red', alpha=0.7, linewidth=1)
plt.legend()
plt.title('Comparison of Load Factors for Renewable and Non-Renewable Generation (Weekly)')
plt.xlabel('Month')
plt.ylabel('Load Factor (%)')
plt.grid(True)
plt.gca().xaxis.set_major_locator(mdates.MonthLocator())
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%b %Y'))
plt.xticks(rotation=45)
plt.show()


#Seasonal and demand
final_df['month'] = final_df['date_time_utc'].dt.month
seasonal_analysis = final_df.groupby('month')[['wholesale market price, gbp/mwh', 'total generation, mwh', 'underlying demand, mw']].mean()

seasonal_analysis.plot(subplots=True, figsize=(12, 10), title='Seasonal Trends in Power Prices and Generation')
plt.show()


# Plot the impact of commodity prices on wholesale market prices
plt.figure(figsize=(12, 6))
plt.plot(final_df['date_time_utc'], final_df['wholesale market price, gbp/mwh'], label='Wholesale Market Price (GBP/MWh)')
plt.plot(final_df['date_time_utc'], final_df['gas price, gbp/mmbtu'], label='Gas Price (GBP/MMBtu)', color='orange')
plt.plot(final_df['date_time_utc'], final_df['coal price, gbp/tonne'], label='Coal Price (GBP/tonne)', color='green')
plt.plot(final_df['date_time_utc'], final_df['carbon price, gbp/tonne'], label='Carbon Price (GBP/tonne)', color='red')
plt.legend()
plt.title('Impact of Commodity Prices on Wholesale Market Prices')
plt.xlabel('Time')
plt.ylabel('Price')
plt.show()


# Calculate correlations
correlation_matrix = final_df[['wholesale market price, gbp/mwh', 'gas price, gbp/mmbtu', 'coal price, gbp/tonne', 'carbon price, gbp/tonne', 'total generation, mwh', 'load factor, %', 'underlying demand, mw']].corr()
# Plot correlation matrix
plt.figure(figsize=(20, 20))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm')
plt.title('Correlation Matrix')
plt.show()


# correlation metrics by generatio methods
# List of generation methods
generation_methods = final_df['name'].unique()

for method in generation_methods:
    method_df = final_df[final_df['name'] == method]

    # Calculate correlations for this method
    correlation_matrix = method_df[
        ['wholesale market price, gbp/mwh', 'gas price, gbp/mmbtu', 'coal price, gbp/tonne', 'carbon price, gbp/tonne',
         'total generation, mwh', 'load factor, %', 'underlying demand, mw']].corr()

    # Plot correlation matrix
    plt.figure(figsize=(12, 8))
    sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm')
    plt.title(f'Correlation Matrix for {method}')
    plt.show()

for method in generation_methods:
    method_df = final_df[final_df['name'] == method]

    # Plot total generation and load factor over time
    fig, axs = plt.subplots(2, 1, figsize=(12, 10), sharex=True)

    axs[0].plot(method_df['date_time_utc'], method_df['total generation, mwh'],
                label=f'{method} - Total Generation (MWh)')
    axs[1].plot(method_df['date_time_utc'], method_df['load factor, %'], label=f'{method} - Load Factor (%)')

    axs[0].set_title(f'Total Generation (MWh) for {method}')
    axs[0].set_ylabel('Total Generation (MWh)')
    axs[0].legend()

    axs[1].set_title(f'Load Factor (%) for {method}')
    axs[1].set_ylabel('Load Factor (%)')
    axs[1].set_xlabel('Time')
    axs[1].legend()

    plt.tight_layout()
    plt.show()



# Split the data into training and testing sets
# X_train, X_test, y_train, y_test = train_test_split(final_df[features], final_df[target], test_size=0.2, random_state=42)
# Splitting the data for training (up to 2019-08-01) and testing (2019-08-01 to 2020-01-01) sets by date
split_date_train = '2019-08-01'
split_date_test = '2020-01-01'
split_date_inference = '2020-09-21'

train_df = model_df[model_df['date'] < split_date_train]
test_df = model_df[(model_df['date'] >= split_date_train) & (model_df['date'] < split_date_test)]

# Define features and target variable
features = ['gas price, gbp/mmbtu', 'coal price, gbp/tonne', 'carbon price, gbp/tonne', 'dayofweek', 'month',
            'lag_1', 'lag_7', 'lag_30', 'rolling_mean_7', 'rolling_std_7', 'rolling_mean_30', 'rolling_std_30']
target = 'wholesale market price, gbp/mwh'

# Split into X and y
X_train = train_df[features]
y_train = train_df[target]
X_test = test_df[features]
y_test = test_df[target]

# Linear
# Initialize the model
linear_model = LinearRegression()

# Train the model
linear_model.fit(X_train, y_train)

# Make predictions for the test period (2019-08-01 to 2020-01-01)
y_pred_test_linear = linear_model.predict(X_test)

# Evaluate the model on test data
mae_test_linear = mean_absolute_error(y_test, y_pred_test_linear)
r2_test_linear = r2_score(y_test, y_pred_test_linear)

print(f'Mean Absolute Error (Test Data): {mae_test_linear}')
print(f'R^2 Score (Test Data): {r2_test_linear}')

# Prepare inference data for 2020 using the same features as training
inference_df = commodities_df[
    (commodities_df['date'] >= split_date_test) & (commodities_df['date'] <= '2020-09-21')].copy()
inference_df['dayofweek'] = inference_df['date'].dt.dayofweek
inference_df['month'] = inference_df['date'].dt.month

# Prepare inference data for 2020 using the same features as training
inference_df = commodities_df[
    (commodities_df['date'] >= split_date_test) & (commodities_df['date'] <= '2020-09-21')].copy()
inference_df['dayofweek'] = inference_df['date'].dt.dayofweek
inference_df['month'] = inference_df['date'].dt.month

# Prepare inference data for 2020 using the same features as training
inference_df = commodities_df[
    (commodities_df['date'] >= split_date_test) & (commodities_df['date'] <= '2020-09-21')].copy()
inference_df['dayofweek'] = inference_df['date'].dt.dayofweek
inference_df['month'] = inference_df['date'].dt.month

# Initialize the current data with the test_df
current_data = test_df.copy()

# Perform recurrent prediction for 2020
future_predictions_linear = []

for i in range(len(inference_df)):
    row = inference_df.iloc[i]

    # Create the feature set for the current prediction
    current_features = {
        'gas price, gbp/mmbtu': row['gas price, gbp/mmbtu'],
        'coal price, gbp/tonne': row['coal price, gbp/tonne'],
        'carbon price, gbp/tonne': row['carbon price, gbp/tonne'],
        'dayofweek': row['dayofweek'],
        'month': row['month'],
        'lag_1': current_data['wholesale market price, gbp/mwh'].iloc[-1] if len(current_data) >= 1 else 0,
        'lag_7': current_data['wholesale market price, gbp/mwh'].iloc[-7] if len(current_data) >= 7 else 0,
        'lag_30': current_data['wholesale market price, gbp/mwh'].iloc[-30] if len(current_data) >= 30 else 0,
        'rolling_mean_7': current_data['wholesale market price, gbp/mwh'].rolling(window=7).mean().iloc[-1] if len(current_data) >= 7 else 0,
        'rolling_std_7': current_data['wholesale market price, gbp/mwh'].rolling(window=7).std().iloc[-1] if len(current_data) >= 7 else 0,
        'rolling_mean_30': current_data['wholesale market price, gbp/mwh'].rolling(window=30).mean().iloc[-1] if len(current_data) >= 30 else 0,
        'rolling_std_30': current_data['wholesale market price, gbp/mwh'].rolling(window=30).std().iloc[-1] if len(current_data) >= 30 else 0,
    }

    # Convert the feature set to a DataFrame
    current_features_df = pd.DataFrame([current_features])

    # Ensure there are no NaN values
    current_features_df.fillna(0, inplace=True)

    # Predict the next price
    predicted_price = linear_model.predict(current_features_df)[0]
    future_predictions_linear.append(predicted_price)

    # Update the current_data for the next iteration
    new_row = row.copy()
    new_row['wholesale market price, gbp/mwh'] = predicted_price
    current_data = pd.concat([current_data, pd.DataFrame([new_row])], ignore_index=True)

# Plot actual vs predicted prices for the test period (2019-08-01 to 2020-01-01)
plt.figure(figsize=(12, 6))
plt.plot(test_df['date'], y_test, label='Actual Wholesale Market Price (GBP/MWh)')
plt.plot(test_df['date'], y_pred_test_linear, label=f'Predicted Wholesale Market Price (GBP/MWh), (MAE: {mae_test_linear:.2f}, R^2: {r2_test_linear:.2f})', alpha=0.7)
plt.xlabel('Date')
plt.ylabel('Wholesale Market Price (GBP/MWh)')
plt.title('Actual vs Predicted Wholesale Market Prices (Linear Regression: Test Data: 2019-08-01 to 2020-01-01)')
plt.legend()
plt.grid(True)
plt.show()

# Plot predicted prices for the entire 2020
fig, ax1 = plt.subplots(figsize=(12, 6))

ax1.plot(inference_df['date'], future_predictions_linear, label='Predicted Wholesale Market Price (GBP/MWh)', color='blue', alpha=0.7)
ax1.set_xlabel('Date')
ax1.set_ylabel('Wholesale Market Price (GBP/MWh)', color='blue')
ax1.tick_params(axis='y', labelcolor='blue')
ax1.legend(loc='upper left')
ax1.grid(True)

# Create a secondary y-axis for gas prices
ax2 = ax1.twinx()
ax2.plot(inference_df['date'], inference_df['gas price, gbp/mmbtu'], label='Gas Price (GBP/MMBtu)', color='red', alpha=0.7)
ax2.set_ylabel('Gas Price (GBP/MMBtu)', color='red')
ax2.tick_params(axis='y', labelcolor='red')
ax2.legend(loc='upper right')

plt.title('Predicted Wholesale Market Prices for 2020 (Linear Regression) with Gas Prices')
plt.show()

# Get the coefficients
coefficients = linear_model.coef_

# Create a DataFrame to display the feature names and their corresponding coefficients
coef_df = pd.DataFrame({'Feature': features, 'Coefficient': coefficients})
coef_df['Absolute Coefficient'] = coef_df['Coefficient'].abs()
coef_df = coef_df.sort_values(by='Absolute Coefficient', ascending=False)

print(coef_df)

# Plot the coefficients with adjusted y-axis label spacing
plt.figure(figsize=(9, 6))
plt.barh(coef_df['Feature'], coef_df['Coefficient'])
plt.xlabel('Coefficient')
plt.ylabel('Feature')
plt.title('Feature Importance (Linear Regression Coefficients)')

# Adjust the y-axis label spacing
plt.gca().yaxis.set_tick_params(labelsize=10, rotation=0)
plt.gca().yaxis.label.set_size(12)
plt.tight_layout()
plt.show()

# Plot partial dependence plots for the top 5 features
top_features = coef_df['Feature'].head(5).tolist()
PartialDependenceDisplay.from_estimator(linear_model, X_train, features=top_features, grid_resolution=50)
plt.suptitle('Partial Dependence Plots')
plt.show()

# Initialize the SHAP explainer
explainer = shap.Explainer(linear_model, X_train)

# Calculate SHAP values for the test set
shap_values = explainer(X_test)

# Summary plot of feature importance
shap.summary_plot(shap_values, X_test)

# Visualize the first prediction's explanation using force plot
shap.force_plot(shap_values[0], matplotlib=True)

# Dependence plot for a specific feature
shap.dependence_plot('gas price, gbp/mmbtu', shap_values.values, X_test)

# XGBoost
# Initialize the XGBoost model
xgb_model = xgb.XGBRegressor(n_estimators=100, random_state=42)

# Train the model
xgb_model.fit(X_train, y_train)

# Make predictions for the test period (2019-08-01 to 2020-01-01)
y_pred_test_xgb = xgb_model.predict(X_test)

# Evaluate the model on test data
mae_test_xgb = mean_absolute_error(y_test, y_pred_test_xgb)
r2_test_xgb = r2_score(y_test, y_pred_test_xgb)

print(f'Mean Absolute Error (Test Data): {mae_test_xgb}')
print(f'R^2 Score (Test Data): {r2_test_xgb}')

# Initialize the current data with the test_df
current_data = test_df.copy()

# Perform recurrent prediction for 2020
future_predictions_xgb = []

for i in range(len(inference_df)):
    row = inference_df.iloc[i]

    # Create the feature set for the current prediction
    current_features = {
        'gas price, gbp/mmbtu': row['gas price, gbp/mmbtu'],
        'coal price, gbp/tonne': row['coal price, gbp/tonne'],
        'carbon price, gbp/tonne': row['carbon price, gbp/tonne'],
        'dayofweek': row['dayofweek'],
        'month': row['month'],
        'lag_1': current_data['wholesale market price, gbp/mwh'].iloc[-1] if len(current_data) >= 1 else 0,
        'lag_7': current_data['wholesale market price, gbp/mwh'].iloc[-7] if len(current_data) >= 7 else 0,
        'lag_30': current_data['wholesale market price, gbp/mwh'].iloc[-30] if len(current_data) >= 30 else 0,
        'rolling_mean_7': current_data['wholesale market price, gbp/mwh'].rolling(window=7).mean().iloc[-1] if len(current_data) >= 7 else 0,
        'rolling_std_7': current_data['wholesale market price, gbp/mwh'].rolling(window=7).std().iloc[-1] if len(current_data) >= 7 else 0,
        'rolling_mean_30': current_data['wholesale market price, gbp/mwh'].rolling(window=30).mean().iloc[-1] if len(current_data) >= 30 else 0,
        'rolling_std_30': current_data['wholesale market price, gbp/mwh'].rolling(window=30).std().iloc[-1] if len(current_data) >= 30 else 0,
    }

    # Convert the feature set to a DataFrame
    current_features_df = pd.DataFrame([current_features])

    # Ensure there are no NaN values
    current_features_df.fillna(0, inplace=True)

    # Predict the next price
    predicted_price = xgb_model.predict(current_features_df)[0]
    future_predictions_xgb.append(predicted_price)

    # Update the current_data for the next iteration
    new_row = row.copy()
    new_row['wholesale market price, gbp/mwh'] = predicted_price
    current_data = pd.concat([current_data, pd.DataFrame([new_row])], ignore_index=True)

# Plot actual vs predicted prices for the test period (2019-08-01 to 2020-01-01)
plt.figure(figsize=(12, 6))
plt.plot(test_df['date'], y_test, label='Actual Wholesale Market Price (GBP/MWh)')
plt.plot(test_df['date'], y_pred_test_xgb, label=f'Predicted Wholesale Market Price (GBP/MWh),(MAE: {mae_test_xgb:.2f}, R^2: {r2_test_xgb:.2f})', alpha=0.7)
plt.xlabel('Date')
plt.ylabel('Wholesale Market Price (GBP/MWh)')
plt.title('Actual vs Predicted Wholesale Market Prices (XGBoost: Test Data: 2019-08-01 to 2020-01-01)')
plt.legend()
plt.grid(True)
plt.show()

# Plot predicted prices for the entire 2020
plt.figure(figsize=(12, 6))
plt.plot(inference_df['date'], future_predictions_xgb, label='Predicted Wholesale Market Price (GBP/MWh)', alpha=0.7)
plt.xlabel('Date')
plt.ylabel('Wholesale Market Price (GBP/MWh)')
plt.title('Predicted Wholesale Market Prices for 2020 (XGBoost)')
plt.legend()
plt.grid(True)
plt.show()

# Random Forest
# Initialize the model
model = RandomForestRegressor(n_estimators=100, random_state=42)

# Train the model
model.fit(X_train, y_train)

# Make predictions for the test period (2019-08-01 to 2020-01-01)
y_pred_test = model.predict(X_test)

# Evaluate the model on test data
mae_test = mean_absolute_error(y_test, y_pred_test)
r2_test = r2_score(y_test, y_pred_test)

print(f'Mean Absolute Error (Test Data): {mae_test}')
print(f'R^2 Score (Test Data): {r2_test}')

# Load JS visualization code to display the plots
shap.initjs()

# Create an explainer object
explainer = shap.TreeExplainer(model)

# Calculate SHAP values for the test set
shap_values = explainer.shap_values(X_test)

# Summary plot of feature importance
shap.summary_plot(shap_values, X_test)

# Visualize the first prediction's explanation
shap.force_plot(explainer.expected_value, shap_values[0,:], X_test.iloc[0,:])

# Dependence plot for a specific feature
shap.dependence_plot('gas price, gbp/mmbtu', shap_values, X_test)

# Prepare inference data for 2020 using the same features as training
inference_df = commodities_df[
    (commodities_df['date'] >= split_date_test) & (commodities_df['date'] <= '2020-09-21')].copy()
inference_df['dayofweek'] = inference_df['date'].dt.dayofweek
inference_df['month'] = inference_df['date'].dt.month

# Prepare inference data for 2020 using the same features as training
inference_df = commodities_df[
    (commodities_df['date'] >= split_date_test) & (commodities_df['date'] <= '2020-09-21')].copy()
inference_df['dayofweek'] = inference_df['date'].dt.dayofweek
inference_df['month'] = inference_df['date'].dt.month

# Prepare inference data for 2020 using the same features as training
inference_df = commodities_df[
    (commodities_df['date'] >= split_date_test) & (commodities_df['date'] <= '2020-09-21')].copy()
inference_df['dayofweek'] = inference_df['date'].dt.dayofweek
inference_df['month'] = inference_df['date'].dt.month

# Initialize the current data with the test_df
current_data = test_df.copy()

# Perform recurrent prediction
future_predictions = []

for i in range(len(inference_df)):
    row = inference_df.iloc[i]

    # Create the feature set for the current prediction
    current_features = {
        'gas price, gbp/mmbtu': row['gas price, gbp/mmbtu'],
        'coal price, gbp/tonne': row['coal price, gbp/tonne'],
        'carbon price, gbp/tonne': row['carbon price, gbp/tonne'],
        'dayofweek': row['dayofweek'],
        'month': row['month'],
        'lag_1': current_data['wholesale market price, gbp/mwh'].iloc[-1],
        'lag_7': current_data['wholesale market price, gbp/mwh'].iloc[-7],
        'lag_30': current_data['wholesale market price, gbp/mwh'].iloc[-30],
        'rolling_mean_7': current_data['wholesale market price, gbp/mwh'].rolling(window=7).mean().iloc[-1],
        'rolling_std_7': current_data['wholesale market price, gbp/mwh'].rolling(window=7).std().iloc[-1],
        'rolling_mean_30': current_data['wholesale market price, gbp/mwh'].rolling(window=30).mean().iloc[-1],
        'rolling_std_30': current_data['wholesale market price, gbp/mwh'].rolling(window=30).std().iloc[-1],
    }

    # Predict the next price
    predicted_price = model.predict(pd.DataFrame([current_features]))[0]
    future_predictions.append(predicted_price)

    # Update the current_data for the next iteration
    new_row = row.copy()
    new_row['wholesale market price, gbp/mwh'] = predicted_price
    current_data = pd.concat([current_data, pd.DataFrame([new_row])], ignore_index=True)

# Plot actual vs predicted prices for the test period (2019-08-01 to 2020-01-01)
plt.figure(figsize=(12, 6))
plt.plot(test_df['date'], y_test, label='Actual Wholesale Market Price (GBP/MWh)')
plt.plot(test_df['date'], y_pred_test, label=f'Predicted Wholesale Market Price (GBP/MWh),(MAE: {mae_test:.2f}, R^2: {r2_test:.2f})', alpha=0.7)
plt.xlabel('Date')
plt.ylabel('Wholesale Market Price (GBP/MWh)')
plt.title('Actual vs Predicted Wholesale Market Prices Random Forest: (Test Data: 2019-08-01 to 2020-01-01)')
plt.legend()
plt.grid(True)
plt.show()

# Plot predicted prices for the entire 2020
plt.figure(figsize=(12, 6))
plt.plot(inference_df['date'], future_predictions, label='Predicted Wholesale Market Price (GBP/MWh)', alpha=0.7)
plt.xlabel('Date')
plt.ylabel('Wholesale Market Price (GBP/MWh)')
plt.title('Random Forest Predicted Wholesale Market Prices for 2020')
plt.legend()
plt.grid(True)
plt.show()

# Plot actual vs predicted prices for the test period (2019-08-01 to 2020-01-01)
plt.figure(figsize=(12, 6))
plt.plot(test_df['date'], y_test, label='Actual Wholesale Market Price (GBP/MWh)')
plt.plot(test_df['date'], y_pred_test_linear, label=f'Linear Regression (MAE: {mae_test_linear:.2f}, R^2: {r2_test_linear:.2f})', alpha=0.7)
plt.plot(test_df['date'], y_pred_test_xgb, label=f'XGBoost (MAE: {mae_test_xgb:.2f}, R^2: {r2_test_xgb:.2f})', alpha=0.7)
plt.plot(test_df['date'], y_pred_test, label=f'Random Forest (MAE: {mae_test:.2f}, R^2: {r2_test:.2f})', alpha=0.7)
plt.xlabel('Date')
plt.ylabel('Wholesale Market Price (GBP/MWh)')
plt.title('Actual vs Predicted Wholesale Market Prices (Test Data: 2019-08-01 to 2020-01-01)')
plt.legend()
plt.grid(True)
plt.show()

#END OF MODELS


